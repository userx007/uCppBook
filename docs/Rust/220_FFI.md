# Foreign Function Interface (FFI): C++ vs. Rust

## Overview

Foreign Function Interface (FFI) is a mechanism that allows code written in one programming language to call functions or use services written in another language. Both C++ and Rust provide robust FFI capabilities, particularly for interoperability with C, which serves as the lingua franca of systems programming.

## C++ FFI Approach

C++ achieves FFI primarily through its direct compatibility with C. Since C++ was designed as an extension of C, it has built-in mechanisms for C interoperability.

### Key Features:
- **Direct C Compatibility**: C++ compilers can directly compile C code
- **Name Mangling Control**: `extern "C"` prevents C++ name mangling
- **ABI Compatibility**: Can expose C-compatible interfaces
- **No Runtime Overhead**: Direct function calls with no abstraction penalty

### C++ FFI Examples

#### Example 1: Exposing C++ Functions to C

```cpp
// math_library.h
#ifndef MATH_LIBRARY_H
#define MATH_LIBRARY_H

#ifdef __cplusplus
extern "C" {
#endif

// C-compatible function declarations
int add(int a, int b);
double calculate_average(const double* values, int count);
void* create_processor();
void destroy_processor(void* processor);

#ifdef __cplusplus
}
#endif

#endif // MATH_LIBRARY_H
```

```cpp
// math_library.cpp
#include "math_library.h"
#include <numeric>
#include <vector>

// Internal C++ class
class DataProcessor {
public:
    std::vector<double> data;
    
    void add_value(double val) {
        data.push_back(val);
    }
    
    double get_sum() const {
        return std::accumulate(data.begin(), data.end(), 0.0);
    }
};

// C-compatible wrapper functions
extern "C" {
    int add(int a, int b) {
        return a + b;
    }
    
    double calculate_average(const double* values, int count) {
        if (count <= 0 || values == nullptr) return 0.0;
        
        double sum = 0.0;
        for (int i = 0; i < count; ++i) {
            sum += values[i];
        }
        return sum / count;
    }
    
    void* create_processor() {
        return new DataProcessor();
    }
    
    void destroy_processor(void* processor) {
        delete static_cast<DataProcessor*>(processor);
    }
}
```

#### Example 2: Calling C Functions from C++

```cpp
// external_c_lib.h (C library)
// This would be provided by a third-party C library
extern "C" {
    typedef struct {
        int id;
        char name[50];
    } CStruct;
    
    void c_function(int value);
    CStruct* create_c_struct(int id, const char* name);
    void free_c_struct(CStruct* ptr);
}

// main.cpp (C++ code calling C)
#include <iostream>
#include <cstring>
#include "external_c_lib.h"

class CppWrapper {
private:
    CStruct* c_obj;
    
public:
    CppWrapper(int id, const char* name) {
        c_obj = create_c_struct(id, name);
    }
    
    ~CppWrapper() {
        if (c_obj) {
            free_c_struct(c_obj);
        }
    }
    
    void display() const {
        if (c_obj) {
            std::cout << "ID: " << c_obj->id 
                      << ", Name: " << c_obj->name << std::endl;
        }
    }
};

int main() {
    // Direct C function call
    c_function(42);
    
    // RAII wrapper around C resource
    CppWrapper wrapper(1, "Example");
    wrapper.display();
    
    return 0;
}
```

## Rust FFI Approach

Rust takes a more explicit and safety-focused approach to FFI. It requires clear declarations and provides tools to ensure memory safety at the boundary between Rust and foreign code.

### Key Features:
- **Explicit `extern` Blocks**: Clearly mark foreign functions
- **`#[repr(C)]`**: Control memory layout for C compatibility
- **Type Safety**: Strong typing with unsafe boundaries
- **Bindgen Tool**: Automatic binding generation from C headers
- **Zero-Cost Abstractions**: No runtime overhead for FFI calls

### Rust FFI Examples

#### Example 1: Calling C Functions from Rust

```rust
// lib.rs - Calling external C library
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_double};

// Declare external C functions
#[link(name = "m")] // Link against libm (math library)
extern "C" {
    fn sqrt(x: c_double) -> c_double;
    fn pow(x: c_double, y: c_double) -> c_double;
}

// Declare custom C library functions
#[repr(C)]
pub struct CPoint {
    x: c_double,
    y: c_double,
}

extern "C" {
    fn calculate_distance(p1: *const CPoint, p2: *const CPoint) -> c_double;
    fn process_string(input: *const c_char) -> *mut c_char;
    fn free_string(ptr: *mut c_char);
}

// Safe Rust wrapper
pub fn safe_sqrt(x: f64) -> f64 {
    unsafe { sqrt(x) }
}

pub fn safe_power(base: f64, exp: f64) -> f64 {
    unsafe { pow(base, exp) }
}

pub struct Point {
    pub x: f64,
    pub y: f64,
}

impl Point {
    pub fn distance_to(&self, other: &Point) -> f64 {
        let p1 = CPoint { x: self.x, y: self.y };
        let p2 = CPoint { x: other.x, y: other.y };
        
        unsafe {
            calculate_distance(&p1, &p2)
        }
    }
}

pub fn process_text(input: &str) -> Result<String, std::str::Utf8Error> {
    let c_string = CString::new(input).expect("CString creation failed");
    
    unsafe {
        let result_ptr = process_string(c_string.as_ptr());
        
        if result_ptr.is_null() {
            return Ok(String::new());
        }
        
        let c_str = CStr::from_ptr(result_ptr);
        let rust_string = c_str.to_str()?.to_owned();
        
        free_string(result_ptr);
        
        Ok(rust_string)
    }
}
```

#### Example 2: Exposing Rust Functions to C

```rust
// rust_library.rs - Exposing Rust to C
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_double};
use std::slice;

// Opaque type for Rust struct
pub struct Calculator {
    accumulator: f64,
}

// C-compatible functions
#[no_mangle]
pub extern "C" fn rust_add(a: c_int, b: c_int) -> c_int {
    a + b
}

#[no_mangle]
pub extern "C" fn rust_calculate_average(values: *const c_double, count: c_int) -> c_double {
    if values.is_null() || count <= 0 {
        return 0.0;
    }
    
    unsafe {
        let slice = slice::from_raw_parts(values, count as usize);
        let sum: f64 = slice.iter().sum();
        sum / count as f64
    }
}

#[no_mangle]
pub extern "C" fn rust_create_calculator() -> *mut Calculator {
    Box::into_raw(Box::new(Calculator { accumulator: 0.0 }))
}

#[no_mangle]
pub extern "C" fn rust_calculator_add(calc: *mut Calculator, value: c_double) {
    if calc.is_null() {
        return;
    }
    
    unsafe {
        (*calc).accumulator += value;
    }
}

#[no_mangle]
pub extern "C" fn rust_calculator_get_result(calc: *const Calculator) -> c_double {
    if calc.is_null() {
        return 0.0;
    }
    
    unsafe { (*calc).accumulator }
}

#[no_mangle]
pub extern "C" fn rust_destroy_calculator(calc: *mut Calculator) {
    if !calc.is_null() {
        unsafe {
            let _ = Box::from_raw(calc);
        }
    }
}

// String handling
#[no_mangle]
pub extern "C" fn rust_process_string(input: *const c_char) -> *mut c_char {
    if input.is_null() {
        return std::ptr::null_mut();
    }
    
    unsafe {
        let c_str = CStr::from_ptr(input);
        let rust_str = match c_str.to_str() {
            Ok(s) => s,
            Err(_) => return std::ptr::null_mut(),
        };
        
        // Process the string (convert to uppercase)
        let processed = rust_str.to_uppercase();
        
        // Convert back to C string
        match CString::new(processed) {
            Ok(c_string) => c_string.into_raw(),
            Err(_) => std::ptr::null_mut(),
        }
    }
}

#[no_mangle]
pub extern "C" fn rust_free_string(ptr: *mut c_char) {
    if !ptr.is_null() {
        unsafe {
            let _ = CString::from_raw(ptr);
        }
    }
}
```

#### Example 3: Using Bindgen (build.rs)

```rust
// build.rs - Automatic binding generation
extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rustc-link-lib=mylib");
    println!("cargo:rerun-if-changed=wrapper.h");

    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
```

```rust
// lib.rs - Using generated bindings
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

pub fn safe_wrapper_function(x: i32) -> i32 {
    unsafe {
        // Call the generated binding
        some_c_function(x)
    }
}
```

#### Example 4: Cross-Language Integration

```rust
// rust_to_cpp.rs - Rust calling C++ (via C interface)
#[repr(C)]
pub struct CppVector {
    data: *mut f64,
    size: usize,
    capacity: usize,
}

#[link(name = "cpplib")]
extern "C" {
    fn cpp_vector_create() -> *mut CppVector;
    fn cpp_vector_push(vec: *mut CppVector, value: f64);
    fn cpp_vector_get(vec: *const CppVector, index: usize) -> f64;
    fn cpp_vector_size(vec: *const CppVector) -> usize;
    fn cpp_vector_destroy(vec: *mut CppVector);
}

pub struct VectorWrapper {
    inner: *mut CppVector,
}

impl VectorWrapper {
    pub fn new() -> Self {
        unsafe {
            VectorWrapper {
                inner: cpp_vector_create(),
            }
        }
    }
    
    pub fn push(&mut self, value: f64) {
        unsafe {
            cpp_vector_push(self.inner, value);
        }
    }
    
    pub fn get(&self, index: usize) -> Option<f64> {
        unsafe {
            let size = cpp_vector_size(self.inner);
            if index < size {
                Some(cpp_vector_get(self.inner, index))
            } else {
                None
            }
        }
    }
    
    pub fn len(&self) -> usize {
        unsafe { cpp_vector_size(self.inner) }
    }
}

impl Drop for VectorWrapper {
    fn drop(&mut self) {
        unsafe {
            cpp_vector_destroy(self.inner);
        }
    }
}

// Usage
fn main() {
    let mut vec = VectorWrapper::new();
    vec.push(1.5);
    vec.push(2.7);
    vec.push(3.9);
    
    println!("Vector length: {}", vec.len());
    if let Some(value) = vec.get(1) {
        println!("Value at index 1: {}", value);
    }
}
```

## Key Differences and Considerations

### Memory Safety
**C++**: Relies on programmer discipline. FFI boundaries can be sources of memory leaks and undefined behavior if not carefully managed.

**Rust**: Uses `unsafe` blocks to explicitly mark FFI boundaries. The type system helps prevent common errors, but unsafe code still requires careful review.

### String Handling
**C++**: Relatively straightforward conversion between `std::string` and `const char*`.

**Rust**: More complex due to ownership and UTF-8 guarantees. Requires `CString`, `CStr`, and careful lifetime management.

### Object Lifetime Management
**C++**: RAII patterns work naturally but require careful wrapper design for C resources.

**Rust**: Explicit ownership transfer with `Box::into_raw()` and `Box::from_raw()`. Drop trait ensures cleanup.

### Tooling
**C++**: Manual header writing or tools like SWIG for complex bindings.

**Rust**: Bindgen provides powerful automatic binding generation from C headers, reducing manual work and errors.

## Summary Table

| Feature | C++ | Rust |
|---------|-----|------|
| **C Interop Mechanism** | `extern "C"` linkage, direct compatibility | `extern "C"` blocks, `#[no_mangle]` |
| **Memory Layout Control** | Natural C compatibility, struct packing pragmas | `#[repr(C)]`, `#[repr(transparent)]` |
| **Safety Guarantees** | None at FFI boundary, relies on programmer | `unsafe` blocks required, compiler helps catch errors |
| **Calling Convention** | `extern "C"` for C ABI, default C++ for internal | `extern "C"` for C ABI, Rust ABI for internal |
| **Name Mangling** | Prevented with `extern "C"` | Prevented with `#[no_mangle]` |
| **String Handling** | `const char*`, manual memory management | `CString`/`CStr`, explicit conversion required |
| **Pointer Handling** | Raw pointers, same as C | Raw pointers in `unsafe`, type-checked |
| **Object Passing** | Opaque pointers (`void*`), manual casting | `Box::into_raw()`/`from_raw()`, type-safe |
| **Automatic Binding Generation** | SWIG, manual headers | Bindgen (C headers → Rust), cbindgen (Rust → C) |
| **Callback Support** | Function pointers, natural | Function pointers, requires `extern "C"` |
| **Error Handling** | Return codes, exceptions (not across boundary) | Return codes, `Result` types (converted at boundary) |
| **Zero-Cost Abstraction** | Yes | Yes |
| **Learning Curve** | Low for C programmers | Moderate, requires understanding ownership |
| **Compile-Time Checks** | Limited at FFI boundary | Strong type checking, lifetime analysis |
| **Runtime Overhead** | None | None |
| **Null Pointer Handling** | Manual checks | Explicit null checks required in `unsafe` |
| **Thread Safety** | Manual synchronization | Send/Sync traits help but don't cross FFI |
| **Documentation** | Manual documentation needed | Doc comments, `bindgen` preserves C comments |
| **Best For** | Integrating with existing C++ codebases, performance-critical code | Building new safe interfaces, gradual C/C++ replacement |

## Conclusion

Both C++ and Rust provide excellent FFI capabilities, but with different philosophies. C++ offers seamless C interoperability with minimal ceremony, making it ideal for projects heavily invested in the C/C++ ecosystem. Rust provides more explicit safety guarantees and better tooling for automatic binding generation, making it excellent for building robust interfaces to C libraries while maintaining Rust's safety properties.

The choice between them often depends on your project's existing codebase, safety requirements, and whether you prioritize ease of integration (C++) or compile-time safety guarantees (Rust).